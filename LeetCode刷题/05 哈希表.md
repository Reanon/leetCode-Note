# 第五课 哈希表、映射、集合

String 和 char [ ]

- ==Arrays.sort 只能作用于char []==
- char[ ] 转为 String类型：String key = ==String.valueOf(ca)==;
- ==String转为char [ ]==：char [] ca = str.toCharArray();

## 242 有效的字母异位词

[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

- 异位词是指字母一样，顺序不同。

### 解题思路一：暴力求解

1. ==排序完==然后进行比对
2. 比较char [] 是否相等：==Arrays.equals(str2,str1)==;

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        // 使用Arrays.sort排序的是数组，切记！！！
        char [] str1 = s.toCharArray();
        char [] str2 = t.toCharArray();
        // 注意是Arrays,sort无返回值
        Arrays.sort(str1);
        Arrays.sort(str2);
        // 调用的接口是Arrays.equals
        return Arrays.equals(str2,str1);
    }
}
```

### 解题思路二：哈希表

1. 为了检查t是否是s的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为s和t都只包含A-Z的字母，所以一个简单的26位计数器表就足够了。
2. 可以用一个计数器表计算s字母的频率，用t减少计数器表中的每个字母的计数器，然后检查计数器是否回到零

![image-20201109110525242](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201109110532.png)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        int [] counter = new int[26];
        for (int i = 0; i < s.length(); i++){
            counter[s.charAt(i) - 'a'] ++;
            counter[t.charAt(i) - 'a'] --;
        }
        for (int count : counter){
            if (count != 0) return false;
        }
        return true;
    }
}
```

## 49 字母异位词分组

[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)：给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

### 解题思路一：排序法

- 字符串用sort按字符编码的顺序默认排序，作哈希表key
- 维护一个映射 ans : {String -> List}，其中**每个键key 是一个排序字符串**，每个值是初始输入的字符串列表，排序后等于key。


```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        if (strs.length == 0) return new ArrayList();
        // 生成String -> List的映射
        Map<String, List> res = new HashMap<String, List>();
        for (String str : strs){
            // String转为char []
            char [] ca = str.toCharArray();
            // Arrays.sort 只能作用于char []
            Arrays.sort(ca);
            // char[] 转为 String类型
            String key = String.valueOf(ca);
            if (!res.containsKey(key)) {
                res.put(key, new ArrayList());
            } 
            res.get(key).add(str);
        }
        // 这里需要new, 通过map.values 转为 值
        return new ArrayList(res.values());
    }
}
```

### 解题思路二：排序 - 异位词

1. 统计字符串中每个字符的个数，最终会生成一个新的字符串，如果生成新的字符串相同，说明他们是==字母异位词==。字母异位词相同，说明字符串相同。
2. 维护一个映射 res: {String -> List}，其中**每个键key 是一个字母异位词**，每个值是初始输入的字符串列表。

![image.png](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201109145044.png)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        // 边界条件判断
        if (strs.length == 0) return new ArrayList();
        Map<String, List> res = new HashMap<String, List>();
        for (String str : strs){
            // 这里要使用char [],而不能使用int []
            char[] ca = new char[26];
            for (char c : str.toCharArray()) {
                // 统计字符串中每个字符串出现的次数
                ca [c - 'a']++;
            }
            // 统计每个字符出现次数的数组转化为字符串
            // String.valueOf(ca)实现char[] 转为String类型
            String key = String.valueOf(ca);
            if (!res.containsKey(key)) {
                res.put(key, new ArrayList());
            } 
            res.get(key).add(str);
        }
        return new ArrayList(res.values());
    }
}
```



## 1 两数之和

[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

### 解题思路一：暴力解法

- 时间复杂度：$O(N^2)$，其中 N是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。
- 空间复杂度：O(1)。

```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length == 1) return new int [0];
        for (int i = 0; i < nums.length - 1; i++){
            // 求解加速
            if (i > 0 && nums[i] == nums[i-1]) continue;
            for (int j = i + 1; j < nums.length; j++){
                if (nums[i] + nums[j]== target){
                    return new int [] {i,j};
                }
            }
        }
        return new int [0];
    }
}
```

### 解题思路二：哈希表

- 遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值
- 如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止

复杂度分析

- 时间复杂度：O(N)，其中 N是数组中的元素数量。对于每一个元素 x，我们可以 O(1)地寻找 target - x。

- 空间复杂度：O(N)，其中 N是数组中的元素数量。主要为哈希表的开销。

```Java
class Solution {
    public int[] twoSum(int[] nums, int target) {
       Map<Integer, Integer> map = new HashMap<>();
       for (int i = 0; i < nums.length; i++){
           // 是否存在target - nums[i]得key
           if (map.containsKey(target - nums[i])) {
               // 返回结果
               return new int [] {map.get(target - nums[i]),i};
           }
           map.put(nums[i], i);
       }
       // 如果找不到的话，就返回[]
       return new int [0];
    }
}
```