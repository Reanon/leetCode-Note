# 第四课  队列、优先队列、双端队列

## 239 滑动窗口最大值

[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。

### 解题思路一：暴力法

最简单直接的方法是遍历每个滑动窗口，找到每个窗口的最大值。一共有 N - k + 1 个滑动窗口，每个有 k 个元素

![image.png](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201106101829.png)

- 时间复杂度为 $O(Nk)$。

本解答会超时。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 边界条件判断
        if (nums == null || nums.length == 0) return new int[0];
        int [] res = new int [nums.length - k + 1];
        // 注意下标，以免出界
        for (int i = 0; i < nums.length - k + 1; i++){
            int max = nums[i];
            // 在每个窗口内找到最大值
            for (int j = 1; j < k; j++){
                max = Math.max(max, nums[i + j]);
            }
            res[i] = max;
        }
        return res;
    }
}
```



### *解题思路二：双端队列

1. 处理前 k 个元素，初始化双向队列。
2. 遍历整个数组。在每一步 :
   1. 清理双向队列 :
      1. 只保留当前滑动窗口中有的元素的索引。
      2. 移除比当前元素小的所有元素，它们不可能是最大的。
3. 将当前元素添加到双向队列中。
4. 将queue[0]添加到输出中。
5. 返回输出数组。

![image.png](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201106104244.png)

![图片.png](https://pic.leetcode-cn.com/8d06a749d24b833dbd619985017aee74ce788090c41d827211dfa799f2d19f0e-图片.png)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 边界条件判断
        if (nums == null || nums.length == 0) return new int[0];
        int [] res = new int [nums.length - k + 1];
        Deque<Integer> queue = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++){
            // 当队内元素超过K，将队头元素移出窗口
            if (!queue.isEmpty() && queue.peekFirst() <= i - k){
                queue.pollFirst();
            }
            // 在添加一个值到队列之前，移除前面比它小的那些值
            while (!queue.isEmpty() && nums[queue.peekLast()] < nums[i]){
                queue.pollLast();
            }
            queue.addLast(i);
            // 从 k-1 才开始添加结果数组
            if (i >= k - 1){
                // 队头元素是队列中最大的，将队列头部的元素加入到数组中
                res[i - k + 1] = nums[queue.peekFirst()];
            }
        }
        return res;
    }
}
```



## 641 设计循环双端队列 

[641. 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)：设计实现双端队列。你的实现需要支持以下操作：

- MyCircularDeque(k)：构造函数,双端队列的大小为k。
- insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
- insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
- deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
- deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
- getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
- getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。
- isEmpty()：检查双端队列是否为空。
- isFull()：检查双端队列是否满了。

### 解题思路一：数组

1. 定义循环变量 `front` 和 `rear` 。
   - `front`：指向队列头部第 1 个有效数据的位置；
   - `rear`：指向队列尾部（即最后 1 个有效数据）的下一个位置，即下一个从队尾入队元素的位置。
2. 为了避免“队列为空”和“队列为满”的判别条件冲突，有意浪费了一个位置。
   - 判别队列为空的条件是：`front == rear` 
   - 判别队列为满的条件是：`(rear + 1) % capacity == front` 

![image-20201107104702988](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201107104703.png)

```java
class MyCircularDeque {

    /** Initialize your data structure here. Set the size of the deque to be k. */
    private int front;
    private int rear;
    private int capacity;
    private int [] array;
    public MyCircularDeque(int k) {
        // 因为要空出一个位置，实际容量加1
        capacity = k + 1;
        array = new int [capacity];
        front = 0;
        rear = 0;
    }
    
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if (isFull()){
            return false;
        }
        front = (front - 1 + capacity) % capacity;
        array[front] = value;
        return true;
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        if (isFull()){
            return false;
        }
        array[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if (isEmpty()) return false;
        // front 被设计在数组的开头，所以是 +1
        front = (front + 1) % capacity;
        return true;
    }
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        if (isEmpty()) return false;
       	// rear 被设计在数组的末尾，所以是 -1
        rear = (rear - 1 + capacity) % capacity;
        return true;
    }
    
    /** Get the front item from the deque. */
    public int getFront() {
        if (isEmpty()) return -1;
        return array[front];
    }
    
    /** Get the last item from the deque. */
    public int getRear() {
        if (isEmpty()) return -1;
        // 当 rear 为 0 时防止数组越界
        return array[(rear - 1 + capacity) % capacity];
    }
    
    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return rear == front;
    }
    
    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        // 注意：这个设计是非常经典的做法
        return front ==  (rear + 1) % capacity;
    }
}
```

### 解题思路二：链表

1. 因为要在头节点和尾节点插入和删除，因此设置两个虚拟节点head，tail
2. 同时参照了[力扣622](https://leetcode-cn.com/problems/design-circular-queue/solution/she-ji-xun-huan-dui-lie-by-leetcode/)中考虑的线程安全问题，对插入和删除操作都加了重入锁，保证了线程安全：[线程安全解答](https://leetcode-cn.com/problems/design-circular-deque/solution/java-lian-biao-shi-xian-shuang-duan-dui-lie-by-er-/)。

```Java
import java.util.concurrent.locks.ReentrantLock;

class MyCircularDeque {
    private int capacity;
    private int size;
    private Node head;
    private Node tail;
    private ReentrantLock dequeLock;

    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        this.capacity=k;
        this.size=0;
        this.head=new Node(-1);
        this.tail=new Node(-1);
        this.dequeLock=new ReentrantLock();
    }

    private static class Node{
        private int val;
        private Node next;
        private Node pre;

        public Node(int value){
            this.val=value;
            this.next=null;
            this.pre=null;
        }
}  
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        try {
            this.dequeLock.lock();
            if (isFull()) return false;
            Node newNode=new Node(value);
            if (this.size==0){
                this.head.next=newNode;
                newNode.pre=this.head;
                newNode.next=this.tail;
                this.tail.pre=newNode;
            }
            else{
                Node temp=this.head.next;
                newNode.next=temp;
                this.head.next=newNode;
                newNode.pre=this.head;
                temp.pre=newNode;

            }
            this.size++;
        }finally{
            this.dequeLock.unlock();
        }
        return true;  
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        try {
            this.dequeLock.lock();
            if (isFull()) return false;
            Node newNode=new Node(value);
            if (this.size==0){
                this.head.next=newNode;
                newNode.pre=this.head;
                newNode.next=this.tail;
                this.tail.pre=newNode;
            }
            else{
                Node temp=this.tail.pre;
                this.tail.pre=newNode;
                newNode.pre=temp;
                temp.next=newNode;
                newNode.next=this.tail;
            }
            this.size++;
        }finally{
            this.dequeLock.unlock();
        }
        return true;
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        try {
            this.dequeLock.lock();
            if (isEmpty()) return false;
            Node temp=this.head.next;
            this.head.next=temp.next;
            temp.next.pre=this.head;
            this.size--;
        }finally{
            this.dequeLock.unlock();
        }
        return true;
    }
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        try {
            this.dequeLock.lock();
            if (isEmpty()) return false;
            Node temp=this.tail.pre;
            this.tail.pre=temp.pre;
            temp.pre.next=this.tail;
            this.size--;
        }finally{
            this.dequeLock.unlock();
        }
        return true;
    }
    
    /** Get the front item from the deque. */
    public int getFront() {
        if (isEmpty()) return -1;
        return this.head.next.val;
    }
    
    /** Get the last item from the deque. */
    public int getRear() {
        if (isEmpty()) return -1;
        return this.tail.pre.val;
    }
    
    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return this.size==0;
    }
    
    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return this.size==this.capacity;
    }
}
```

