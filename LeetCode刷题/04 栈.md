# 第四课 栈

## ArrayDeque 类

[ArrayDeque类的使用详解](https://www.cnblogs.com/chenglc/p/10722304.html)：`ArrayDeque`是`Deque`接口的一个实现，使用了可变数组，所以没有容量上的限制。

1. `ArrayDeque`是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。
2. `ArrayDeque`是`Deque`的实现类，可以作为栈来使用，效率高于`Stack`；
3. 可以作为队列来使用，效率高于`LinkedList`。
4. 需要注意的是，`ArrayDeque`不支持`null`值。

## 20 有效的括号

[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

### 解题思路一：栈、哈希表

- 如果 c 是左括号，则入栈 push；
- 否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 false。

![image-20201103100520418](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201103100528.png)

**提前返回 false**

- 提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。
- 解决边界问题：
  - 栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ? ，并在哈希表 dic 中建立 key: `?`，value:`?`的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 false；
  - 字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；

**复杂度分析**

- 时间复杂度 O(N)：正确的括号组合需要遍历 1 遍 `s`；
- 空间复杂度 O(N)：哈希表和栈使用线性的空间大小。

```java
class Solution {
    public boolean isValid(String s) {
        // 构建映射表，前一个是key,后一个是值
        // 使用了双层花括号初始化 map
        Map<Character, Character> map = new HashMap<Character, Character>() {
            {
                put('{', '}');
                put('(', ')');
                put('[', ']');
            }
        };
        // 特判语句很重要的
        if (s.length() > 0 && !map.containsKey(s.charAt(0))) {
            return false;
        }
        // 使用Deque 模拟栈，一般使用pop()、push()和peek()
        Deque<Character> stack = new LinkedList<>();
        // String.toCharArray:生成char数组
        for (Character c : s.toCharArray()) {
            // 如果c是左括号的话就放入栈中
            if (map.containsKey(c)) {
                stack.push(c);
            } else {
                // 如果c是右括号的话，先判断栈是否为空
                // 再将栈顶元素弹出比较是否等于c
                if (stack.isEmpty() || !map.get(stack.pop()).equals(c)) {
                    return false;
                }
            }
        }
        // 判读栈是否为空
        return stack.isEmpty();
    }
}
```

ArrayDeque模拟栈

```java
class Solution {
    public boolean isValid(String s) {
        // 构建映射表，前一个是key,后一个是值
        // 使用了双层花括号初始化 map
        HashMap<Character, Character> map = new HashMap<>(){
            {
                put('(', ')');
                put('{', '}');
                put('[', ']');
            }
        };
        // 初始语句判断
        if (s.length() > 0 && !map.containsKey(s.charAt(0))){
            return false;
        }
        // 使用ArrayDeque模拟栈
        Deque<Character> stack = new ArrayDeque<>();
        for (char c : s.toCharArray()){
            if (map.containsKey(c)){
                stack.addLast(c);
            }else {
                if (stack.isEmpty() || !map.get(stack.pollLast()).equals(c)){
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
```



### 解题思路二：简洁写法

```Java
class Solution {
    public boolean isValid(String s) {
        // 也是用双端队列模拟栈
        Deque<Character> stack = new LinkedList<>();
        for (char c : s.toCharArray()){
           	// switch 后面是加花括号的
            switch (c) {
                case '(': stack.push(')'); break;
                case '{': stack.push('}'); break;
                case '[': stack.push(']'); break;
                default:
                   	// 使用.equals() 方法判断是否相等
                    // 注意需要判断stack是否为空
                    if (stack.isEmpty() || !stack.pop().equals(c)) return false;
            }
        }
        // 返回值也是判断是否为空
        return stack.isEmpty();
    }
}
```



## 155 最小栈

[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

```java
class MinStack {

    /**
     * initialize your data structure here.
     */
    // 保存所有元素
    Deque<Integer> stack;
    // 保存最小元素的栈
    Deque<Integer> minStack;
    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
    }
    public void push(int x) {
        // 需要使用‘>=’来将次小的元素保存下来。
        if (minStack.isEmpty() || minStack.peek().compareTo(x) >= 0) {
            minStack.push(x);
        }
        stack.push(x);
    }

    public void pop() {
        // 判断弹出的是否为最小的元素，若是，则需要将最小栈的顶端元素弹出
        if (stack.pop().equals(minStack.peek())) {
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

## 84 柱状图中最大的矩形

[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

### 解题思路一：暴力解法

依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。

- 从`i`向两边遍历，找到左边和右边第1个严格小于height[i]的时候停下，中间的长度就是最长底边

![image.png](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105212627.png)

复杂度分析

- 时间复杂度：$O(n^2)$，这里n是高度数组的长度。
- 空间复杂度：$O(1)$，使用常数个临时变量。

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        // 特判
        if (len == 0) return 0;
        if (len == 1) return heights[0];
        int res = 0;
        for (int i = 0; i < len; i++) {
            // left 和 right 都指在 >= height[i]的高度内
            int left = i;
            // 找左边最后 1 个大于等于 heights[i] 的下标
            while (left > 0 && heights[left-1] >= heights[i]){
                left --;
            }
		   // 找右边最后 1 个大于等于 heights[i] 的索引
            int right = i;
            // 这里是 len - 1
            while (right < len -1 && heights[right + 1] >= heights[i]){
                right ++;
            }
            int width = right -left + 1;
            res = Math.max(res, width * heights[i]);
        }
        return res;
    }
}
```

### 解题思路二：栈

![image-20201106100555477](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201106100555.png)

```java
public class Solution {

    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        if (len == 0) return 0;
        if (len == 1) return heights[0];
        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>(len);
        for (int i = 0; i < len; i++) {
            // 这个 while 很关键，因为有可能不止一个柱形的最大宽度可以被计算出来
            while (!stack.isEmpty() && heights[i] < heights[stack.peekLast()]){
                int curHeight = heights[stack.pollLast()];
                while (!stack.isEmpty()  && curHeight == heights[stack.peekLast()]) {
                    stack.pollLast();
                }
                int curWidth;
                // 如果栈为空，则说明左边界在0处，即width = i - 0
                if (stack.isEmpty()){
                    curWidth = i;
                }else {
                    curWidth = i - stack.peekLast() - 1; 
                }
                res = Math.max(res, curWidth * curHeight);
            }
            // 将i添加进栈
            stack.addLast(i);
        }
        while (!stack.isEmpty()){
            int curHeight = heights[stack.pollLast()];
            while (!stack.isEmpty()  && curHeight == heights[stack.peekLast()]) {
                stack.pollLast();
            }
            int curWidth;
            // 剩下在栈里的元素都可以扩散到右边
            if (stack.isEmpty()){
                curWidth = len;
            }else {
                curWidth = len - stack.peekLast() - 1; 
            }
            res = Math.max(res, curWidth * curHeight);
        }
        return res;
    }
}
```

### * 解题思路三：单调栈、哨兵

需要考虑两种特殊的情况：

1. 弹栈的时候，栈为空；
2. 遍历完成以后，栈中还有元素；

哨兵==（Sentinel）==：

- 使用「哨兵」(Sentinel) ，避免特殊情况的讨论;
- 「哨兵」技巧的其它应用：单链表虚拟头结点、插入排序。

![image-20201105222644071](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201105222644.png)

这里栈对应到高度，呈单调增加不减的形态，因此称为==单调栈（Monotone Stack）==。它是暴力解法的优化，计算每个柱形的高度对应的最大矩形的顺序由出栈顺序决定。

```java
public class Solution {

    public int largestRectangleArea(int[] heights) {
        if (heights.length == 0) return 0;
        if (heights.length == 1) return heights[0];
        // 创建一个新的数组来储存多出来的两个哨兵
        int len = heights.length;
        int [] newHeight = new int [len + 2];

        // 将heights 复制到 newHeights
        newHeight[0] = 0;
        newHeight[len + 1] =0;
        // len 是复制的长度
        // 是arraycopy
        System.arraycopy(heights, 0 ,newHeight, 1, len);

        heights = newHeight;
        Deque<Integer> stack = new ArrayDeque<>();
        stack.addLast(0);
        int res = 0;
        len = heights.length;
        for (int i = 1; i < len; i++){
            // 放入哨兵，在循环里就不用做非空判断，未考虑相等的情况，会往后滑。
            while (heights[stack.peekLast()] > heights[i]){
                // 这里把要计算的高给poll出来了
                int height = heights[stack.pollLast()];
                // 这里需要画图来进行理解
                // 若为1 -> 2 -> 3, 此时i指向3，poll出2，peek出1
                // 则 2的宽度为，3 - 1 - 1，即为1
                int width = i - stack.peekLast() - 1;
                res = Math.max(res, width * height);
            }
            stack.addLast(i);
        }       
        return res;
    }
}
```



## 42 接雨水

[42. 接雨水（困难）](https://leetcode-cn.com/problems/trapping-rain-water/)：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。



[ 739. 每日温度（中等）](https://leetcode-cn.com/problems/daily-temperatures/)

[496. 下一个更大元素 I（简单）](https://leetcode-cn.com/problems/next-greater-element-i/)

[316. 去除重复字母（困难）](https://leetcode-cn.com/problems/remove-duplicate-letters/)

[901. 股票价格跨度（中等）](https://leetcode-cn.com/problems/online-stock-span/)

[402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)