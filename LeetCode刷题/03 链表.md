# 第三课 数组、链表、跳表-Linked List

**练题步骤**

1. 5-10分钟：读题和思考
   - 有思路：自己开始做和写代码；
   - 不然，马上看题解！
2. 第一遍：默写背诵、熟练
3. 第二遍：然后开始自己写（闭卷）

## 206 单链表反转

[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)：反转一个单链表。

### 解题思路一：双指针迭代

1. 申请两个指针，第一个指针叫 pre，最初是指向 null的。
2. 第二个指针 cur 指向 head，然后不断遍历 cur。
3. 每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
4. 都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了，pre就是新的头节点，返回pre

![迭代.gif](https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-迭代.gif)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        // 申请节点，prev和 cur，prev指向null,temp指向cur的下一个节点
        ListNode prev = null;
        ListNode cur = head;
        ListNode temp = null;
        while (cur != null) {
            //记录当前节点的下一个节点
            temp = cur.next;
            //然后将当前节点指向pre
            cur.next = prev;
            //pre和cur节点都前进一位
            prev = cur;
            cur = temp;
        }
        return prev;
    }
}
```

### 解题思路二：递归解法

递归的两个条件：

1. 终止条件是当前节点 或者 下一个节点==null
2. 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head ：`head.next.next = head`

![递归.gif](https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-递归.gif)

```Java
class Solution {
    public ListNode reverseList(ListNode head) {
        // 递归终止条件是下一个节点为空：head.next == null
        // 初始如果head ==null 则直接返回
        if (head == null || head.next == null)
            return head;
        //这里的newHead就是最后一个节点
        ListNode newHead = reverseList(head.next);
        //如果链表是 1->2->3->4->5，那么此时的newHead就是5
        //而head是4，head的下一个是5，下下一个是空
        //所以head.next.next 就是5->4
        head.next.next = head;
        //防止链表循环，需要将head.next设置为空
        head.next = null;
        //每层递归函数都返回newHead，也就是最后一个节点
        return newHead;
    }
}
```

## 24 两两交换链表中的节点

[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

### 解题思路一：迭代（哑节点）

可以通过一个哑节点来实现：

1. 创建哑结点 `dummyHead`，令 `dummyHead.next = head`； `prev` 表示当前到达的节点，初始时 `prev = dummyHead`。每次需要交换 `prev` 后面的两个节点。
   1. 如果 `prev` 的后面没有节点或者只有一个节点：没有更多的节点需要交换，因此结束交换。
   2. 如果还有节点：获得 `prev` 后面的两个节点 `node1` 和 `node2`，通过更新节点的指针关系实现两两交换节点。
2. 交换节点：
   1. 交换之前的节点关系是 `prev -> node1 -> node2`
   2. 交换之后的节点关系要变成 `prev -> node2 -> node1`

图中`temp`用`prev`替代

![image-20201027173645919](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201027173645.png)

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        // 新建哑节点
        ListNode dummyHead = new ListNode(0, head);
        // prev在node1和node2之前
        ListNode prev = dummyHead;
        while (prev.next != null && prev.next.next != null) {
            ListNode node1 = prev.next;
            ListNode node2 = prev.next.next;
            // 更新节点的指针关系实现两两交换节点。
            prev.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            // 将prev移动到下一对节点之前
            prev = node1;
        }
        return dummyHead.next;
    }
}
```

### * 解题思路二：递归

递归应该关心的主要有三点：

1. ==返回值==：交换完成的子链表
2. ==调用单元==：设需要交换的两个点为 head 和 newHead，head 连接后面交换完成的子链表rest，newHead 连接 head，完成交换
3. ==终止条件==：head 为空指针或者 head.next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换

![image-20201027200113273](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201102095723.png)

-  `head` 表示原始链表的头节点，也是新的链表的第二个节点。
- `newHead` 表示新的链表的头节点，也是原始链表的第二个节点`head.next`。
- 原始链表中其余节点的头节点是 `rest = head.next.next`
- 交换后的剩余节点的头节点为 `head.next` 的下一个节点： `head.next = swapPairs(rest);`
- 完成了所有节点的交换，最后返回新的链表的头节点newHead

```Java
public ListNode swapPairs(ListNode head) {
    	//递归的终止条件
        if (head == null || head.next == null) {
            return head;
        }
    	// 假设链表是 head -> 1 -> 2 -> 3 -> 4
    	// rest -> 3
   		ListNode rest = head.next.next;
    	// newHead -> 2
        ListNode newHead = head.next;
    	// newHead -> 2 -> 1
    	newHead.next = head;
    	// 当递归结束返回后，就变成了rest -> 4 -> 3
    	// 于是head节点就指向了4，变成head -> 1 -> 4 -> 3
        head.next = swapPairs(rest);
    	// newHead -> 2 -> 1(head) -> 4(rest) -> 3
        return newHead;
}
```

## 141 环形链表

[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)：给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。如果链表中存在环，则返回 true 。 否则，返回 false 。

### 解题思路一：快慢指针

判断链表是否有环应该是老生常谈的一个话题了

- 快慢指针：慢指针针每次走一步，快指针每次走两步，如果相遇就说明有环，如果有一个为空说明没有环。
- 快指针每次走两步，慢指针每次走一步，每走一次快慢指针的间距就要缩小一步
  - 在图一中当走n次的时候就会相遇；
  - 图二中当走m-n次的时候就会相遇

![image.png](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201028194848.png)

```Java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        //快慢两个指针
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            // 慢指针每次走一步
            slow = slow.next;
            // 快指针每次走两步
            fast = fast.next.next;
            // 如果相遇，说明有环，直接返回true
            if (fast == slow)
                return true;
        }
        // 否则就是没环
        return false;
    }
}
```

### 解题思路二：存放到集合中

1. 把节点存放到集合set中
2. 每次存放的时候判断当前节点是否存在
   1. 如果存在，说明有环，直接返回true
   2. 否则返回 false

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        Set<ListNode> set = new HashSet<>();
        while (head != null) {
            //如果重复出现说明有环,contains
            if (set.contains(head)) {
                return true;
            }
            // 否则就把当前节点加入到集合中
            set.add(head);
            head = head.next;
        }
        // 否则就是没环
        return false;
    }
}
```



## 142 环形链表 II

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)：给定一个链表，==返回链表开始入环的第一个节点==。 如果链表无环，则返回 null。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。说明：不允许修改给定的链表。

### 解题思路一：哈希表

1. 遍历链表中的每个节点，并将它记录下来；
2. 一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。

- 时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。
- 空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        Set<ListNode> set = new HashSet<ListNode>();
        ListNode point = head;
        while (point != null) {
            if (set.contains(point)) {
                return point;
            }
            set.add(point);
            point = point.next;
        }
        return null;
    }
}
```

### 解题思路二：快慢指针

使用两个指针：fast与slow。它们起始都位于链表的头部；slow指针每次向后移动一个位置，而fast指针向后移动两个位置；如果链表中存在环，则 fast指针最终将再次与slow指针在环中相遇。

![fig1](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201028204025.png)

如果环比较小，快指针在环上转了好几圈了，慢指针才走到环上，假如快指针在环上已经走了n圈了，慢指针在环上走了m圈，他们最终在环上相遇，那么

- 慢指针走过的距离是：$Distance_{slow} = a+b+m\times(b+c)$
- 快指针走过的距离是：$Distance_{fast} = a+b+n \times (b+c)$

在相同的时间内快指针走过的距离是慢指针的2倍，故有：
$$
a+b+n \times(b+c) = 2 (a+b+m \times (b+c))
$$
整理得到：$a+b=(n-2m)(b+c)$

即从相遇点到入环点的距离加上 $(n-2m)$圈的环长，恰好等于从链表头部到入环点的距离。因此，当发现slow 与fast 相遇时，我们再额外使用一个指针ptr。起始，它指向链表头部；随后，它和slow 每次向后移动一个位置。最终，它们会在入环点相遇。

- 时间复杂度：O(n)
  - 两次遍历级别都在$O(n)$，即$O(n)＋O(n)= O(n)$。
- 空间复杂度：$O(1)$

```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        // 快慢指针，快指针每次走两步，慢指针每次走一步
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            // 比较是否指向同一个节点，而不是比节点的值
            // 判断是否有环
            if (slow == fast) {
                //两相遇指针，一个从头结点开始，一个从相遇点开始每次走一步，直到再次相遇为止
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        return null;
    }
}
```



## * 25 K 个一组翻转链表  

[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

### 解题思路一：递归

1. 找到待翻转的k个节点（注意：若剩余数量小于 k 的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。
2. 对其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。
3. 对下一轮 k 个节点也进行翻转操作。
4. 将上一轮翻转后的尾结点指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。

![img](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201028210747.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null || k <= 1) return head;
        ListNode tail = head;
        for (int i = 0; i < k; i++) {
            // 剩余数量小于k的话，则不需要反转。
            if (tail == null)
                return head;
            tail = tail.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverse(head, tail);
        // 下一轮的开始的地方就是tail
        head.next = reverseKGroup(tail, k);
        return newHead;
    }

    /*
     * 翻转链表：[head, tail)
     */
    private ListNode reverse(ListNode head, ListNode tail) {
        // 左闭又开区间
        ListNode prev = null;
        ListNode cur = head;
        ListNode temp = null;
        while (cur != tail) {
            temp = cur.next;
            cur.next = prev;
            prev = cur;
            cur = temp;
        }
        return prev;
    }
   /*
   * 递归翻转版本:1 ms
   */
    private ListNode reverse (ListNode head, ListNode tail){
        // 边界条件判断从head == null 变成了判断head == tail
        if (head == tail || head.next == tail) return head;
        // 传入的参数是 head.next
        ListNode newHead = reverse(head.next, tail);
        head.next.next = head;
        // 这里也变成了指向tial,而不是指向null
        head.next = tail;
        return newHead;
    }
}
```

