# 第六课 树、二叉树、二叉搜索树



![img](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201116141302.png)

## 094  二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)：给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 解题思路一：递归

递归终止的条件为碰到空节点，定义 inorder(root) 表示当前遍历到 root 节点的答案

1. 递归调用 inorder(root.left) 来遍历 root 节点的左子树
2. 将root 节点的值加入答案
3. 再递归调用inorder(root.right) 来遍历root 节点的右子树即可

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
- 空间复杂度：O*(*n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inOrder(root, res);
        return res;
    }
    private void inOrder(TreeNode root, List<Integer> res) {
        if (root == null) return;
        //按照 左-打印-右的方式遍历
        inOrder(root.left, res);
        res.add(root.val);
        inOrder(root.right, res);
    }
}
```

### 解题思路二：栈

- 这里使用官方推荐的方式模拟栈

```java
// 新建栈
Deque <TreeNode> stack = new ArrayDeque<>();
// 添加入栈元素
stack.addLast(xxx)
// 删除栈顶元素
stack.pollLast()
```

- 递归的调用过程是不断往左边走，当左边走不下去了；就打印节点；并转向右边一步，然后右边继续这个过程。

- 在迭代实现时，就可以用栈来模拟上面的调用过程。

![1.gif](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113090916.gif)

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
- 空间复杂度：O*(*n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque <TreeNode> stack = new ArrayDeque<>();
        while (root != null || !stack.isEmpty()) {
            // 不断往左子树方向走，每走一次就将当前节点保存到栈中
            while (root != null) {
                stack.addLast(root);
                root = root.left;
            }
            // 当前节点为空，说明左边走到头了，从栈中弹出节点并保存
            root = stack.pollLast();
            res.add(root.val);
            // 然后转向右边节点，继续上面整个过程
            root = root.right;
        }
        return res;
    }
}
```

### * 解题思路三：线索二叉树 Morris

Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：

1. 新建临时节点node，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点(即左子树中序遍历的最后一个节点)。
   1. 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
   2. 如果前驱节点的右子节点为当前节点，说明我们已经遍历完 当前节点的左子树，将它的右子节点重新设为空。==将当前节点加入答案（主要区别）==，当前节点更新为当前节点的右子节点。
4. 重复步骤 2 和步骤 3，直到遍历结束。

**注意**：**中序遍历**中当前节点的值，是在==左子树为空==或者==遍历完左子树==时添加

![image-20201113092942157](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113092942.png)

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。==Morris 遍历中每个节点会被访问两次==，因此总时间复杂度为 O(2n)=O(n)。
- 空间复杂度：O*(*1)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        TreeNode predecessor = null;
        TreeNode node = root;
        while (node != null) {
            if (node.left != null) {
                // 如果当前节点node有左孩子，则找到node 左子树上最右的节点
                // predecessor 节点就是当前节点向左走一步，然后一直向右走至无法走为止
                predecessor = node.left;
                while (predecessor.right != null && predecessor.right != node) {
                    predecessor = predecessor.right;
                }
           
                // predecessor.right == node 判断前驱是否被找到过
                if (predecessor.right == null) {
                    // 如果 predecessor 的右孩子为空，则将其右孩子指向 node
                    predecessor.right = node;
                    // 然后访问 node 的左孩子
                    node = node.left;
                }else {
                    // 如果 predecessor 的右孩子不为空，说明我们已经遍历完 node 的左子树, 此时其右孩子指向 node
                    // 将 predecessor 的右孩子置空,将 node 的值加入答案数组
                    predecessor.right = null;
                    res.add(node.val);
                    // 然后访问 x 的右孩子，即 x=x.right
                    node =node.right;
                }
            }else {
                // 如果 x 无左孩子，先将 x 的值加入答案数组
                res.add(node.val);
                // 再访问 x 的右孩子，即 x=x.right
                node = node.right;
            }
        }
        return res;
    }
}
```

## 144 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)：给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

### 解题思路一：递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        preOrder(root, res);
        return res;        
    }
    private void preOrder (TreeNode root, List<Integer> res) {
        if (root == null) return;
        res.add(root.val);
        preOrder(root.left, res);
        preOrder(root.right, res);
    }
}
```

### 解题思路二：栈

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode node = root;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {
                res.add(node.val);
                stack.addLast(node);
                root = node.left;
            }
            root = stack.pollLast();
            root = root.right;
        }
        return res;
    }
}
```

### 解题思路三：线索二叉树

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点.
   1. 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。==将当前节点加入答案（主要区别）==，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
   2. 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
4. 重复步骤 2 和步骤 3，直到遍历结束。

**注意**：**前序遍历**中当前节点的值，是在==左子树为空==或者==找到当前节点的前驱时==时添加

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        TreeNode node = root;
        TreeNode predecessor = null;
        while (node != null) {
            if (node.left != null) {
                predecessor = node.left;
                while (predecessor.right != null && predecessor.right != node) {
                    predecessor = predecessor.right;
                }
                if (predecessor.right == null) {
                    // 找到当前节点前驱之后，就将节点添加
                    // 主要区别
                    res.add(node.val);
                    predecessor.right = node;
                    // 寻找下一个节点
                    node = node.left;
                }else{
                    predecessor.right = null;
                    node = node.right;
                }
            }else {
                res.add(node.val);
                node = node.right;
            }
        }
        return res;
    }
}
```

## 145 二叉树的后序遍历

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)：给定一个二叉树，返回它的 *后序* 遍历。

### 解题思路一：递归

```Java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postOrder(root, res);
        return res;       
    }
    private void postOrder(TreeNode node, List<Integer> res) {
        if (node == null) return;
        postOrder(node.left, res);
        postOrder(node.right, res);
        res.add (node.val);
    }
}
```



### 解题思路二：前序遍历反转

仔细思考一下就会发现，后序遍历是左右中，前序遍历是中左右。

- 那么我们只需要把前序遍历稍微改一下顺序，变成==前序遍历中右左==
- 然后把得到的数组反转一下就好了。

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode node = root;
        while (node != null || !stack.isEmpty()) {
            // 前序遍历
            while (node != null) {
                // 先添加值
                res.add(node.val);
                stack.addLast(node);
                // * 先向右走
                node = node.right;
            }
            node = stack.pollLast();
            node = node.left;
        }
        // 使用集合方法，翻转双向链表
        Collections.reverse(res);
        return res;
    }
}
```

## 102 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**普通的层序遍历**

层序遍历就是把二叉树分层，然后每一层从左到右遍历。结果得到是一维数组

![BFS 遍历的过程（动图）](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201116115811.gif)

```Java
void bfs(TreeNode root) {
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.addLast(root);
    while (!queue.isEmpty()) {
        
        TreeNode node = queue.pollFirst(); 
        if (node.left != null) {
            queue.addLast(node.left);
        }
        if (node.right != null) {
            queue.addLast(node.right);
        }
    }
}
```

### 解题思路一：广度优先搜索

在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。

![img](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201116115654.gif)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<TreeNode> queue = new ArrayDeque<>();
        if (root != null) {
            queue.addLast(root);
        }
        while (!queue.isEmpty()) {
            // 记录当前层的节点数
            int n = queue.size();
            List<Integer> level = new ArrayList<>();
            // 将当层节点添加进结果
            for (int i = 0; i < n; i++ ) {
                TreeNode node = queue.pollFirst();
                level.add(node.val);
                if (node.left != null) queue.addLast(node.left);
                if (node.right != null) queue.addLast(node.right);
            }
            res.add(level);
        }
        return res;
    }
}
```



```java

```



```java

```

## 590 N叉树的后序遍历

[590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)：给定一个 N 叉树，返回其节点值的后序遍历。

### 解题思路一：递归

后序遍历常用方法

- 二叉树：左 -> 右 -> 根
- ==N叉树：子节点 -> 根==

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<Integer> postorder(Node root) {
        List<Integer> res = new  ArrayList<>();
        postOrder(root, res);
        return res;
    }
    private void postOrder (Node node, List<Integer> res) {
        if (node == null) return;
        // 遍历子节点
        for (Node child : node.children) {
            postOrder(child, res);
        }
        // 遍历完子节点，添加根节点
        res.add (node.val);
    }
}
```

### 解题思路二：迭代

使用一个栈来得到后序遍历。

1. 首先把根节点入栈。
2. 当每次从栈顶取出一个节点 u 时，就把 u 的所有子节点顺序推入栈中。
3. 例如 u 的子节点从左到右为 v1, v2, v3，那么推入栈的顺序应当为 v1, v2, v3，这样就保证了下一个遍历到的节点（即 u 的第一个子节点 v3）出现在栈顶的位置。
4. 在遍历结束之后，==将遍历结果反转，就可以得到后序遍历==。

```java
class Solution {
    public List<Integer> postorder(Node root) {
        // 使用LinkedList 实现头添加
        LinkedList<Integer> res = new LinkedList<>();
        Deque<Node> stack = new ArrayDeque<>();
        if (root == null) return res;
        Node node = root;
        stack.addLast(node);
        while (!stack.isEmpty()) {
            node = stack.pollLast();
            // 从前往后添加节点，实现逆序的效果
            res.addFirst(node.val);
            for (Node child : node.children) {
                stack.addLast(child);
            }
        }
        return res;
    }
}
```



## 589 N叉树的前序遍历

[589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)：给定一个 N 叉树，返回其节点值的*前序遍历*。

### 解题思路一：递归

```java
class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        preOrder(root, res);
        return res;
    }

    private void preOrder(Node node, List<Integer> res) {
        if (node == null ) return;
        // 先添加元素的值
        res.add(node.val);
        for (Node child : node.children) {
            preOrder(child, res);
        }
    }
}
```

### 解题思路二：迭代

使用一个栈来帮助我们得到前序遍历，需要保证栈顶的节点就是我们当前遍历到的节点。

1. 首先把根节点入栈，因为根节点是前序遍历中的第一个节点。
2. 每次从栈顶取出一个节点 u，它是我们当前遍历到的节点，并把 u 的所有子节点逆序推入栈中。
3.  u 的子节点从左到右为 v1, v2, v3，那么推入栈的顺序应当为 v3, v2, v1
   - 这样就保证了下一个遍历到的节点（即 u 的第一个子节点 v1）出现在栈顶的位置。

```java
class Solution {
    public List<Integer> preorder(Node root) {
        List<Integer> res = new ArrayList<>();
        Deque<Node> stack = new ArrayDeque<>();
        if (root == null) return res;
        Node node = root;
        stack.addLast(node);
        // 以栈是否为空作为判断程序是否结束
        while (! stack.isEmpty()) {
            node = stack.pollLast();
            res.add(node.val);
            // 将当前节点的子节点进行翻转
            Collections.reverse(node.children);
            for (Node child : node.children) {
                // 逆序添加子节点
                stack.addLast(child);
            }
        }
        return res;
    }
}
```

## 429 N叉树的层序遍历

[429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)：给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

### 解题思路一：利用队列实现广度优先搜索

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<Node> queue = new ArrayDeque<>();
        if (root == null) return res;
        Node node = root;
        queue.addLast(node);
        while (!queue.isEmpty()) {
            // 获取本层节点的数目
            int n = queue.size();
            List<Integer> level = new ArrayList<Integer>();
            for (int i = 0; i < n; i++) {
                node = queue.pollFirst();
                level.add(node.val);
                for (Node child : node.children) {
                    queue.addLast(child);
                }
            }
            res.add(level);
        }
        return res;
    }
}
```

