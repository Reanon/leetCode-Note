# 第六课 树、二叉树、二叉搜索树



## 94  二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)：给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

### 解题思路一：递归

递归终止的条件为碰到空节点，定义 inorder(root) 表示当前遍历到 root 节点的答案

1. 递归调用 inorder(root.left) 来遍历 root 节点的左子树
2. 将root 节点的值加入答案
3. 再递归调用inorder(root.right) 来遍历root 节点的右子树即可

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
- 空间复杂度：O*(*n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inOrder(root, res);
        return res;
    }
    private void inOrder(TreeNode root, List<Integer> res) {
        if (root == null) return;
        //按照 左-打印-右的方式遍历
        inOrder(root.left, res);
        res.add(root.val);
        inOrder(root.right, res);
    }
}
```

### 解题思路二：栈

- 这里使用官方推荐的方式模拟栈

```java
// 新建栈
Deque <TreeNode> stack = new ArrayDeque<>();
// 添加入栈元素
stack.addLast(xxx)
// 删除栈顶元素
stack.pollLast()
```

- 递归的调用过程是不断往左边走，当左边走不下去了，就打印节点，并转向右边，然后右边继续这个过程。

- 在迭代实现时，就可以用栈来模拟上面的调用过程。

![1.gif](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113090916.gif)

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
- 空间复杂度：O*(*n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque <TreeNode> stack = new ArrayDeque<>();
        while (root != null || !stack.isEmpty()) {
            // 不断往左子树方向走，每走一次就将当前节点保存到栈中
            while (root != null) {
                stack.addLast(root);
                root = root.left;
            }
            // 当前节点为空，说明左边走到头了，从栈中弹出节点并保存
            root = stack.pollLast();
            res.add(root.val);
            // 然后转向右边节点，继续上面整个过程
            root = root.right;
        }
        return res;
    }
}
```

### * 解题思路三：线索二叉树 Morris

Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：

1. 新建临时节点node，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点(即左子树中序遍历的最后一个节点)。
   1. 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
   2. 如果前驱节点的右子节点为当前节点，说明我们已经遍历完 当前节点的左子树，将它的右子节点重新设为空。==将当前节点加入答案（主要区别）==，当前节点更新为当前节点的右子节点。
4. 重复步骤 2 和步骤 3，直到遍历结束。

**注意**：当前节点的值，是在==左子树为空==或者==遍历完左子树==时添加

![image-20201113092942157](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201113092942.png)

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。==Morris 遍历中每个节点会被访问两次==，因此总时间复杂度为 O(2n)=O(n)。
- 空间复杂度：O*(*1)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        TreeNode predecessor = null;
        TreeNode node = root;
        while (node != null) {
            if (node.left != null) {
                // 如果当前节点node有左孩子，则找到node 左子树上最右的节点
                // predecessor 节点就是当前节点向左走一步，然后一直向右走至无法走为止
                predecessor = node.left;
                while (predecessor.right != null && predecessor.right != node) {
                    predecessor = predecessor.right;
                }
           
                // predecessor.right == node 判断前驱是否被找到过
                if (predecessor.right == null) {
                    // 如果 predecessor 的右孩子为空，则将其右孩子指向 node
                    predecessor.right = node;
                    // 然后访问 node 的左孩子
                    node = node.left;
                }else {
                    // 如果 predecessor 的右孩子不为空，说明我们已经遍历完 node 的左子树, 此时其右孩子指向 node
                    // 将 predecessor 的右孩子置空,将 node 的值加入答案数组
                    predecessor.right = null;
                    res.add(node.val);
                    // 然后访问 x 的右孩子，即 x=x.right
                    node =node.right;
                }
            }else {
                // 如果 x 无左孩子，先将 x 的值加入答案数组
                res.add(node.val);
                // 再访问 x 的右孩子，即 x = x=x.right
                node = node.right;
            }
        }
        return res;
    }
}
```

## 144 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)：给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

### 解题思路一：递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        preOrder(root, res);
        return res;        
    }
    private void preOrder (TreeNode root, List<Integer> res) {
        if (root == null) return;
        res.add(root.val);
        preOrder(root.left, res);
        preOrder(root.right, res);
    }
}
```

### 解题思路二：栈

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode node = root;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {
                res.add(node.val);
                stack.addLast(node);
                root = node.left;
            }
            root = stack.pollLast();
            root = root.right;
        }
        return res;
    }
}
```

### 解题思路三：线索二叉树

Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：

1. 新建临时节点，令该节点为 root；
2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点.
   1. 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。==将当前节点加入答案（主要区别）==，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
   2. 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
4. 重复步骤 2 和步骤 3，直到遍历结束。

**注意**：当前节点的值，是在==左子树为空==或者==找到当前节点的前驱时==时添加

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        TreeNode node = root;
        TreeNode predecessor = null;
        while (node != null) {
            if (node.left != null) {
                predecessor = node.left;
                while (predecessor.right != null && predecessor.right != node) {
                    predecessor = predecessor.right;
                }
                if (predecessor.right == null) {
                    // 找到当前节点前驱之后，就将节点添加
                    // 主要区别
                    res.add(node.val);
                    predecessor.right = node;
                    // 寻找下一个节点
                    node = node.left;
                }else{
                    predecessor.right = null;
                    node = node.right;
                }
            }else {
                res.add(node.val);
                node = node.right;
            }
        }
        return res;
    }
}
```

## 590 N叉树的后序遍历

[590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)：给定一个 N 叉树，返回其节点值的后序遍历。

解题思路一：

```java

```







```java

```





```java

```





```java

```





```java

```

