# 03 链表

自由刷题，自己做着玩的。补助基础功夫。

## 剑18 删除链表的节点

[剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)：给定单向链表的==头指针==和一个要删除的节点的值，定义一个函数删除该节点。

### 解题思路一：迭代

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0, head);
        ListNode prev = dummyHead;
        while (prev != null && prev.next != null){
            if (prev.next.val == val){
                prev.next = prev.next.next;
            }
            prev = prev.next;
        }
        return dummyHead.next;     
    }
}
```

### 解题思路二：递归

1. 终止条件：head == null,直接返回head；head.val == val, 返回head.next;
2. 返回值：每一层调用都返回==链表的下一个节点==

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if (head == null) return head;
        // 返回head.next
        if (head.val == val) return head.next;
	    // 返回的下一个节点是删除之后的节点
        head.next = deleteNode(head.next, val);
        return head;
    }
}
```

## 237 删除链表中的节点

[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)：请编写一个函数，使其可以删除某个链表中给==定的（非末尾）节点==。传入函数的唯一参数为 **要被删除的节点** 。

### 解题思路：与下一个节点交换

删除链表节点（相当于把删除节点与下一节点 交换，next直接指向下一节点的下一节点）

- 删除节点val = 下一节点val
- 删除节点next = 下一节点next

![img](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201030201405.png)



```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

## 19 删除链表的倒数第N个节点

[19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)：给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

### 解题思路一：快慢指针

使用两个指针，一个指针fast先走n步，然后另一个指针slow从头结点开始，找到要删除结点的前一个结点，这样就可以完成结点的删除了。

```Java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head;
        ListNode slow = head;
        // fast移n步
        for (int i = 0; i < n; i++){
            fast = fast.next;
        }
        // 如果fast为空，表示删除的是头结点
        if (fast == null){
            return head.next;
        }
        // 边界条件：fast指向最后一个节点，此时fast.next = null
        // slow的下一个就是要删除的节点
        while (fast.next != null){
            // 不停地移动fast和slow，直到fast指向最后一个节点。
            slow = slow.next;
            fast = fast.next;
        }
    	// 删除slow的下一个节点
        slow.next = slow.next.next;
        return head;
    }
}
```

## 21 合并两个有序链表

[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

### 解题思路一：迭代

比较两个链表头节点值的大小，值小的节点作为合并之后链表的头节点；之后哪个链表的头节点的值更小，另一链表的节点依次插入到这个链表中。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode tail = dummyHead;
        while (l1 != null && l2 != null){
            if (l1.val <= l2.val){
                tail.next = l1;
                l1 = l1.next;
            }else {
                tail.next = l2;
                l2 = l2.next;
            }
            tail = tail.next;
        }
        tail.next = l1 == null ? l2 : l1;
        return dummyHead.next;
    }
}
```

### 解题思路二：递归

递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素

1. 终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束
2. 返回值：每一层调用都==返回排序好的链表头==
3. 本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理
   O(m+n)，m为 l1的长度，n 为 l2 的长度

![image-20201030211439669](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201030211439.png)

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null){
            return l2;
        }
        if (l2 == null){
            return l1;
        }
        
        if (l1.val < l2.val){
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }   
    }
}
```

## 234 回文链表

[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)：请判断一个链表是否为回文链表。

### 解题思路一：快慢指针

所谓的回文链表就是以链表中间为中心点两边对称；使用两个指针，一个最左边一个最右边，两个指针同时往中间靠，判断所指的字符是否相等。

- 通过找到==链表的中间节点==然后把链表后半部分反转
- 最后再用后半部分反转的链表和前半部分一个个比较即可。

![image.png](https://aliyun-typora-img.oss-cn-beijing.aliyuncs.com/imgs/20201030213247.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        // 通过快慢指针找到中点
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        // 如果fast不为空，说明链表的长度是奇数个
        if (fast != null){
            slow = slow.next;
        }
        // 反转后半部分链表
        slow = reverse(slow);
        fast = head;
        while (slow != null){
            // 然后比较，判断节点值是否相等
            if (slow.val != fast.val) {
                return false;
            }
            slow = slow.next;
            fast = fast.next;
        }
        return true;
    }

    // 通过递归翻转链表
    private ListNode reverse(ListNode head){
        if (head == null || head.next == null) return head;
        ListNode newHead = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
    
    // 通过迭代进行翻转
    private ListNode reverse (ListNode head){
        ListNode prev = null;
        while (head != null){
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```

### 解题思路二：栈

- ==栈是先进后出的一种数据结构==，这里可以使用栈先把链表的节点全部存放到栈中，然后再一个个出栈，这样就相当于链表从后往前访问

```java
class Solution {
        public boolean isPalindrome(ListNode head) {
        if (head == null) return true;
        Stack<Integer> stack = new Stack<>();
        ListNode temp = head;
        //链表的长度
        int length = 0;
        //把链表节点的值存放到栈中
        while (temp != null){
            stack.push(temp.val);
            temp = temp.next;
            length++;
        }
        // length长度除以2
        length >>= 1;
        // 出栈进行比较
        while (length-- > 0){
            if (head.val != stack.pop())
                return false;
            head = head.next;
        }
        return true;
    }
}
```

### 解题思路三：数组法

1. 复制链表值到数组列表中。
2. 使用双指针法判断是否为回文。

注意：比较的是==节点值的大小==：`node_1.val == node_2.val`，而不是节点本身。

- 时间复杂度：O(n)，其中 n 指的是链表的元素个数。
  - 第一步： 遍历链表并将值复制到数组中，O(n)。
  - 第二步：双指针判断是否为回文，执行了 O(n/2)次的判断，即 O(n)。
    总的时间复杂度：O(2n) = O(n)。
- 空间复杂度：O(n)，其中 n 指的是链表的元素个数，使用了一个数组列表存放链表的元素值。

```Java
class Solution {
        public boolean isPalindrome(ListNode head) {
        if (head == null ) return true;
        List <Integer> values = new ArrayList<>();
        // 将链表的值复制到数组中
        ListNode temp = head;
        while (temp != null){
            // 通过add来添加元素
            values.add(temp.val);
            temp = temp.next;
        }
        
        int front = 0;
        // 使用size取得大小
        int rear = values.size() - 1;
        // 使用双指针判断是否回文
        while (front < rear){
           	// ArrayList 使用get来取值，使用equals判断是否相等
            if (!values.get(front++).equals(values.get(rear--))){
                return false;
            }
        }
        return true;
    }
}
```

